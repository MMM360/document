# java基础
java基础以thinking in java来进行入门.
说实话,thinking in java这本书不仅仅适合新手,而且适合比较资深的人员.
由于书籍相对顶级峰会和论文的滞后性,一些内容并不适合专家这个title的.大家注意
我会罗列一下java基础.然后介绍一下自己学习的深度

1. java基础-小白级别到新手级别
1.1 面向对象.简单知道面向对象是什么就好了.
1.2 java语言基础:jvm概念,半静态,.class定义,环境变量,操作符,基本语法(if,for),内置变量类型等.
1.3 jvm基础:内存概念,初始化过程,gc过程,访问控制,变量类型(这些仅仅知道概念即可)
1.4 java-api系列:java容器系列(list,map),string,io,泛型等(图形化记得不用学了)
1.5 简单设计:方法重写/重载,java的类继承,多态的概念.封装的概念等

可以说学完第一步就到了java的小白级别了.注意小白级别关注点是"浅尝即止".这里面的很多内容是java专家级别都不一定能回答好的.所以千万别走弯路.

我举个例子,java容器系列里面有个HashMap.有个问题是HashMap的内存结构和并发控制.这个问题曾经问倒了80%的阿里开发.所以最怕的以为自己会了其实是错的.

学完这些内容了就达到了"新手级别".哈下面几个问题各位可以简单想想.回答的上来就是新手级别了

Q1:static一个方法和static一个变量,使用他们的时候访问的内存是一样的么?
Q2:方法重写时,需要不需要方法的返回值必须相同.

后面简单介绍一下java新手-工作人需要的东西.还有天坑为什么说这些概念复杂.

# hashmap
就hashmap的问题我引用一下内网ata的描述 大家可以看看师傅真的理解了

看到代码规约这一条的时候，我觉得是不是有点太 low 了，身为开发，大家都知道 HashMap 的原理。

什么？这个要通过插件监测？没必要吧，哪个开发不知道默认大小，何时 resize 啊，然后我和孤尽打赌随机咨询几位同学以下几个问题：

HashMap 默认bucket数组多大？
如果new HashMap<>(19)，bucket数组多大？
HashMap 什么时候开辟bucket数组占用内存？
HashMap 何时扩容？
抽样调查的结果出乎我的意料：

HashMap 默认bucket数组多大？（答案是16，大概一半的同学答错）
如果new HashMap<>(19)，bucket数组多大？（答案是32，大多被咨询同学都不太了解这个点）
HashMap 什么时候开辟bucket数组占用内存？（答案是第一次 put 时，一半同学认为是 new 的时候）
HashMap 何时扩容？（答案是put的元素达到容量乘负载因子的时候，默认16*0.75，有1/4同学中枪）
HashMap 是写代码时最常用的集合类之一，看来大家也不是全都很了解。孤尽乘胜追击又抛出问题：JDK8中 HashMap 和之前 HashMap 有什么不同？

# 工作技能
当初lz由于是自学.所以直接就奔着找工作去的.所以我的经历比较适合奔着工作去或者入门的程序员提升自己的人来学习.

## 框架基础
之前说了来到了上海,lz第二个选择是互联网公司.所以内容都是互联网公司的一些经验.
对于企业级并不一定完全满足
### 新手
1. jdbc.事实上软件的本质也是信息和数据的处理.所以作为java访问数据库的基础.jdbc肯定肯定是需要完全了解的.
2. ORM框架,目前比较火的应该还是mybatis.这些半orm框架是一定要掌握的.可以学习helloword然后思考功能实现,最后思考数据层如何设计
3. spring.spring作为一个框架,现在基本上已经脱离框架了.现在更像一个完备的技术栈.ps.我完全没有学习过springboot.因为我学习的时候还没有springboot.现在也完全不用springboot.对于新人来说**必须**先学习spring的基础之后再来学习其他的
4. 服务端mvc框架,推荐springmvc.如果是cs类的架构可能会用一些restfull的框架,不过无所谓.这些架构还比较简单.
5. web容器.tomcat了解一下?

以上就是新手的内容了.全部学习完毕可以说自己是初级java开发了.当然了前提是必须在理解的基础上再来表示自己学会.还是两个问题.

Q1:简单介绍一下服务器使用tomcat情况下类加载器和spring类加载器的交互
Q2:为什么说mybatic是半orm框架




## 初级开发者的"面向对象"
### 导论
面向对象这个概念,应该是大家学习java或者是学习编程遇到的第一个"坎".
因为这个概念对于新手来说是十分抽象的.大家一开始很难理解什么是"对象".什么叫面向对象编程.

这里我简单使用一个例子来表述一下:盖房子.

这个例子真的和软件开发十分相似,建筑行业的很多思想也和软件开发类似.

我们盖房子需要一个东西:"结构".我们需要定义这个房子的结构和框架以便大家理解.
同时软件编程一样,我们需要定义一个事物来"组织"我们的代码.

所以对于新人来说.首先理解"面向对象"是一种编程方法.是一种对于代码进行组织然后实现
业务功能的方法和设计思想.

### 何为对象
可能编程中最难的部分就是理解什么是对象了.上面我们理解面向对象是代码组织的一种方法.

那么这个方法具体是什么呢?我个人的理解就两个字:抽象.

即.我们需要用代码来实现真实社会中的一个功能,一个事情或者表现真实社会中的事务.
但是代码又全都是一个个符号和语法.如何能真正的组织我们的代码.然后实现功能呢.

这个时候必须对现实生活中的一些"特征"进行抽象,然后映射到我们的编程设计中.这种特征的抽象
就是抽象出一个个对象的概念.

比如我们设计一个程序用来卖苹果.那么在程序中.苹果就可以是一个对象.他的特征是有重量和有数量.

然后进一步.我们会针对"数量"和"重量"来进行实现售卖的功能.然后大家发现我们自然而然的忽略了"苹果"
这两个字.这就是之前说的"抽象".而面向对象就是把一个个实物进行抽象,用我们的代码进行组织

所以,请记住"对象"是对现实事务的特征的一种抽象.

### 何为面向对象编程
介绍完何为"对象".我们继续介绍如何运用对象进行编程.

还是上面卖苹果的例子.我们把苹果抽象成了"数量"和"重量".那么售卖者会提供一个功能,价钱=`"数量"*"重量"*"单价"`
这就是我们组织代码的方式.

其核心的本质就是.我们基于"万物皆对象"这种方法,组织我们自己的代码.从而让代码能够有一定的聚合和分类.让代码好理解一些.

所以对于新人来理解面向对象:这是一种编程方式.编程绝对不是几百上千个if和循环组成的.而应该是一个个对象互相交互形成的

注意!新人在写代码的时候可以强制要求自己使用多个对象来组成自己的功能.千万别写一个几百行的大功能


### 面向对象的基本技术
当我们理解了面向对象的一些概念之后.我们可以尝试使用面向对象来解决问题.大家应该知道.不仅仅是"我们"来用面向对象.同时有非常多的前人一样使用面向对象的工具来解决问题.所以这些前人的智慧就形成了一些公用的方法.

这些通常的做法和解决具有某些特征的问题的方法叫:设计模式.

大家可以通过设计模式来更加进一步的理解面向对象技术.
此外,除了设计模式以外还有一些java语言支持的操作和原则.我们同样可以学习
比如面向对象五大原则:SRP,OCP,LSP,DIP,ISP.这些内容.

当然初级开发可以从一些基本的面向对象操作来学习
比如:接口,实现类,继承,多态,包装.这些概念,然后自己思考然后来写一个程序.

## 中级开发的面向对象
### 导论
其实对于中级开发,可能已经应用了大量的面向对象的编程技术了.比如spring就是一个大的工厂设计模式实现的ioc.

所以慢慢"如何写代码"以及如何组织自己的代码,如何来实现一些CRUD已经不是问题了.甚至能脱口而出一些设计模式,用设计模式的思考方法来思考一些内容.

所以此时就开始理解面向对象为一种"设计"方式了.此时考虑的不仅仅是实现,而且是整个"架构"来如何"设计".而考虑架构的时候就是一个设计的使用方法了.




## 面试经历

lz主要的经历是两次面试第一次可能更有说服力

第一次是我从大连跳槽道上海之后来找的工作 几乎完全自学的java 然后去找到的工作 第一份工作到手8.8k 大家可以参考

1.1 技能篇
1.1.1 javase
好像大家都叫这个名字 就是面试中高级java必定被问的问题 还有一些特殊的公司 比如如果面试支付宝是楼主做面试官的话 第一面我会面50%的java基础 50%的架构思路 所以这部分看面试官的风格 不一而足

lz个人的话准备的技术栈可以完全按照thinking in java来准备
分别是 java内存结构 gc基础 io基础 线程并发基础 容器基础 
然后每个知识栈准备五个递进问题 作为面试的基础能力考察部分
lz个人第一次面试只到第三个问题 由于这里不是技术篇 所以我这里不过多介绍基础内容 只抛出简单的介绍 具体的解答和分析会单独罗列

技能篇-java内存结构
1. 典型jvm的内存结构（以hotspot为例） 主要是堆 栈 方法区 介绍不同发内存的内存作用 声明一个对象的时候的内存使用
2. 每个内存具体存的内容 最长问的是方法区 部分 包括常量池和class文件部分的价值和存储 static关键字的使用等等
3. java版本信息 这里需要注意（我每次面试别人必定问）jdk1.8之后对于pemgen有优化 变成了metaspace 这个是可伸缩的变量区（之前是不可以伸缩的）需要重点了解变化地点
4. did一次面试lz没有达到的 系统级别的内存概念和java内存交互 比如寄存器和内存指令的交互

技能篇-并发
1. 引子 引入线程并发感念 考察常见的并发场景的处理方法 比如lz遇到的共享map的并发处理 答使用collections 1.5之后可以（记不清了）使用concurrent hash map
2. 具体并发控制的api的不同 主要是1.5之后新增了java.consurrent 包里面有新增的并发读写锁这个和synchronise不同
3. 并发访问下的内存分配 我们知道线程是java概念 进程是系统概念 那么java在申请线程的时候是如何和系统交互的 比如volitae 关键字的作用和内存控制 如内存级别的内存和共享内存
4. 内存指令的排序 如何保证对于共享内存处理的有序和线程内存如何刷新到共享内存

技能篇-容器
1. hashmap的原理 数据结构 hash的链表散列原理 equalse方法和hashcode方法在hashmap中的使用（先hashcode进行确定index来确定buget如果碰撞则比较equalse方法然后形成链表）

2. hashmap的进阶原理 对于大小的控制 对于concurrentmodification ex的问题等等内容

3. 不同jdk版本下的hashmap原理 主要还是jdk1.8下对于hashmap进行了优化然后jdk1.5下对于hashmap的并发进行了优化

4. 对于hashmap在分布式业务下的应用 比如hash值的负载均衡 一致性hash等内容

1.1.2 javaee部分
javaee部分根据不同的面试企业可能考察的方面不一样 比如外包的公司可能重点考察javaee的框架serverlet和jsp 前端框架等内容 互联网公司可能重点考察常用框架如spring myvatis等内容 所以一定要做好规划啊


javaee-spring
spring这么说吧 现在不懂spring可以说不懂java了 现在spring可以说是一个一个完整的技术栈 lz面试的时候被问的是spring的设计思想和事务处理 所以这里说明这两点

1. spring的设计思想 di和ioc解决的问题 为什么使用spring进行配置而不是直接new 这里我的理解是面向对象思想的解释和面向对象设计五大原则然后引入架构风格最后解释技术选项的思考

我自己的回答 首先spring是一个轻量级的容器框架 基于工程模式封装了所有bean的构建方法生命周期
这种方式比e**轻量级非常多 并且对于架构设计来说控制上下文和bean的构建方法是控制架构范围的一种方法 如面向对象原则里面的ocp和lsp都是说了内聚和面对抽象设计 这样必须对于抽象的实现提供框架级别的支持
解释完上面之后再说 在做技术选型的时候需要考虑方方面面 对于spring这种容器及上下文的选择已经经过很多大型系统的验证 社区也非常丰富并且掌握的人足够多 所以是最合适的



###楼主面试别人问题
1. 自我介绍
主要精力是后台维护工作.用springMvc及mybatis等内容.

2. 框架技术内容
问对于restfull的理解.问对于restfull和springmvc的设计如何实现的多视图.以及操作幂等性.整体回答不是很好.对于幂等性没有理解深刻,回答同请求加密来进行绑定判断.同时对于restfull这种的
候选人使用了redis.就redis进行问redis的使用场景.回答订单缓存和订单的加锁,进一步追问如何来实现的订单加锁,进一步追问是否有数据单点问题,是否有对于单点问题的解决方案.候选人没有给出答案

3. 对于aop编程思想的提问
问什么是aop,以及如何使用的aop.候选回答的全是springmvc相关的内容.以及如何实现springmvc,对于aop的使用概念和理念没有理解清晰.并且回答很久不用了所以不记得了.现在的系统也没有使用
扩展性问题,如何让候选人重新设计自己的系统架构如何来进行设计.
候选人回答到了对于数据进行拆分.所以追问如何拆表和拆表后对于数据一致性如何保证.发现候选人对数据一致性不了解.

4. javacore相关问题
问候选人hashmap的内存结构.回答链表散列.达到3/4会进行扩展.为什么是3/4(默认的负载系数)候选人没回答上来.对于rehash也没有回答ok,对于如何确定数组的index没有回答上来.对于jkd1.8没有涉及.
对于如何控制并发.候选人答实际工作中没有使用.没有了解到.


#lz的自我学习经历

先明确一点.我的经历已经是快五年前的了.所以希望大家结合现在的变化来进行更新.
并且当初由于处于O2O风口,所以经济形势很好.上海很多创业公司,lz也是加入了一家初创公司.打下了架构基础.
目前已经快三年没有找工作了.所以不太确定目前就业形势.不过从猎头给我的反馈来看还不错.

#lz学习java的经历.

学习java的经历可以说是废寝忘食.有近半年的时间吧(太久远忘记了).lz的作息是
早上7点起床洗漱吃早点.开始看视频.一直看到中午.下午继续看视频或者回顾视频中的内容.完全自学加写代码.
晚上加深学习加扩展内容.根据进度学习到凌晨1点到3点.期间没有上过网.没有任何娱乐活动.


#gc
1.1.3 java初始化,内存分配与gc
java相对于c++来说,对于内存的使用"智能"了很多.不用手工清理内存,也不用手工初始化内存.
但是编程语言仅仅是一种工具.我们要正确的理解如何干活,之后工具仅仅是协助我们干好活的一个手段.
所以对于一些偏底层及原理性内容需要完全理解

首先是初始化内容,对于constructor理解概念,知道是静态代码和"实例对象"的概念.这个概念会伴随我们使用java的全部生涯.
不要小看这个概念,这里简单介绍一下.我们的所有架构设计都是面对静态代码的.代码运行的针对我们的设计会具象化到某个场景
这就是实例对象.
在大型系统架构中,涉及复杂业务及系统架构.我们往往使用"配置化"的表达方式来进行涉及,这其实就一个静态代码和实例对象的关系.

然后需要了解一个完整的实例对象的顺序问题.比如成员变量,静态变量.构造方法,构造代码块,这些顺序.写一个程序会帮助大家理解的更深.

然后就是重中之重.java的内存分配了.对于一个初学者.可能无法理解太深的java内存分配的原理.所以这部分就是靠记忆来理解.
比如最简单的堆,栈,方法区.这三个内存.
同时,需要联系我们上面说的初始化内容来学习这里.比如一行代码:
String a = new String("a");
这里会开辟几个内存空间?依次的顺序是什么?引用关系是什么?这些需要大家都弄清楚.

然后,非常建议大家提前了解一些gc原理.java是被动式的gc.通过System.gc();也是无法强制gc的.关于gc的文章非常非常多.
大家可以简单了解一下gc对于堆内存的划分.知道概念即可.因为涉及到了内存.所以gc一定要配合学习一下.

总结一下
1. 我们学习了java初始化.重点理解实例对象概念,需要记忆初始化顺序问题,基本技能是构造方法
2. 学习了内存分配.知道当我们进行变量声明,赋值,实例化对象的时候内存发送了什么样子的变化.分别每部分内存是哪.
3. 对于gc知道了这么一个东西.

###数组，容器
1.1.4 数组,容器
java提供了一套非常有用且强大的api,通过这套api几乎可以满足绝大部分工作中对于数据存储转换传递的需要.
这就是java的容器类.这里的容器是指java当中存放对象的一些数据结构.简单来说就是放数据的内容
学习容器首先需要理解容器的概念和容器能帮助我们做什么.在实际工作中经常会对一些数据处理.通过java处理一批数据必定需要
把这些数据放起来.然后做操作.java当中的容器就是放这些东西的类.

就像之前我所讲的.对于面向对象来说,我们需要对于我们的功能进行抽象.所以java当中提供了一些接口来表达容器对应的功能
容器有:Collection,Map
进一步划分有:List,Set
容器的实现有:
ArrayList,LinkedList,Vector->Stack
HashSet->LinkedHashSet,TreeSet
HashMap->LinkedHashMap,TreeMap
这里就很有意思了.大家发现实现类有这么多种,是不是没一个都是不用的用法呢?
其实只有两个,一个是Collection一个是Map.
这就是我之前说的抽象的概念,我们抽象的是通用操作方法.不同的实现提供的是内部不同的功能实现.一个相同的操作方法可能会有不同的表现形式.希望大家体会体会.

同样,对于容器的迭代使用java也抽象出了公用的迭代器:Iterator,用于封装同样的访问方法.虽然map无法直接使用迭代器进行访问,但是map的key和entry是可以使用的.这些内容比较基础.大家学习会各个容器的访问和设置方法自己多联系联系即可

下面说一些学习核心:
1. 对于了解容器类.首先需要了解的是每一个不同容器的实现逻辑和内存结构.一定要至少知道内存结构.比如ArrayList是一个数组,LinkedList是一个链表结构.
同样的.对于HashMap重点理解"链表散列"这个概念.如果实在无法理解,就多多看几遍代码.HashMap在设计上有个hash思想.这个通过Hash值来离散数据的设计可以用在很多地方.可以多多理解,比如数据水平拆分,负载均衡设计.包括分布式缓存中的一致性hash设计.都是基于这个.

2. 对于不同内存结构.带来功能和性能上的不同需要理解到.比如经常问到的Array和Linked这两个的性能区别和使用场景区别
需要能够自己理解到.比如随机访问的情况用LinkedList还是ArrayList?
答案是都不用,重写hashCode方法然后用HashMap.希望大家真的能理解这点.

3. 对于容器的迭代器.插入删除的并发控制.目前记住这点内容即可.后续在并发的时候重点有并发的讲解

4. map是一个很特殊的容器.因为使用场景实在太多了.所以jdk1.8对hashMap进行了优化.大家一定要去详细了解一下.(这里不说了.因为这个都已经可以形成一个blog了)

5. 常用编程规范.目前学习到现在应该养成一些编程规范了.比如初始化容器的时候指定大小这些.

###多线程与并发
1.1.5 多线程与并发
多线程和容器需要一起来看.前几天面试一个同学的时候就挂在多线程这部分了.他说他的web开发中几乎用不到多线程.
当时我就立即说到.tomcat的线程模型是什么.不同的req是不是运行在不同的线程里面?只是你没有关注过罢了.

所以可以看出来.如果不是做基础架构.一般多线程使用场景较少.一般用多线程的场景也建议使用统一异步调度的方式来进行.
比如在蚂蚁,定时调度使用schedule和三层分发来做.
但是大家必须意识到.自己的程序天然就是运行在多线程里面的.

在面试过程中会单独考察多线程的概念和联合容器一起考察.后者工作中用到的更多.

###java多线程体系
java多线程体系:
1. 基本的多线程操作.Thread类.启动线程的方法.线程并发的概念.线程安全的处理方式.Sync的方式
然后就是 jdk 1.5中的concurrent包中的新的方式.Lock和Sync的区别.这些基础必须学习好
2. 线程通信的概念,notify的含义.volatile的底层处理方式
3. 底层cpu指令集.性能概述
4. 在工作中使用容器时的并发处理.如map是如何进行并发控制的ConcurrentHashMap和Collections.con的区别是什么.
5. 线程模型.如boss线程守护.多线程轮训的方式.这里涉及到线程池的概念.Executor的处理

多线程的内容非常非常多.需要大量的阅读书籍和练习才能掌握.对于一开始学习java来说.可以考虑先了解概念
针对面试常问的来学习.一般我在面试的时候会重点问下面几个问题
1. 多线程并发控制方式. 答案:api方式sync和lock. 设计方式去掉共享变量.
2. 容器的并发控制方式区别.map的区别和性能.
3. 线程池的相关操作.

由于一般在工作中极少极少用到notify相关内容.所以一般较少考察.不过建议大家学习的时候一定要学习会.
比如下面这个联系题
A,B,C三个线程执行任务.X发放任务.按照A->B->C的方式进行多线程处理任务.用代码实现.

希望大家思考思考.用sync和notify的方式来做

###java异常处理
1.1.6 java异常处理
java对于异常很多人诟病很多.不过基于java异常也可以实现很多优雅的设计.
并且异常也是非常多架构设计中需要考虑的内容.所以针对java的异常学习.除了需要学习基本的概念意外.
需要重点掌握的是针对异常的一些设计.
对于基础知识.
1. 最简单的.了解Throwable,Error,Exception,RuntimeException这些的概念.并且知道用法.对于try-catch-finally需要明白是做什么的
2. 异常设计.一些基本的设计概念.比如通用的需要检查的异常处理内容.方法上抛出的异常.try-catch处理转换.日志打印等内容

对于基础知识来说大家肯定用到了.比如多线程的时候就有打断异常.所以这里不过多介绍.
我更加想给大家介绍一些基本的异常设计方法.可能大家不会太理解.不过知道这个概念也行

工业场景下的典型异常设计方法:
1. RuntimeException
事实上,对于Exception真的是深恶痛绝.这个东西真的会让代码变的非常难看.我们更希望使用非检查异常.并且是自定义异常.
所以最基础的就是.一般我们会设计一个基础异常比如 MyException 继承RuntimeException.
然后把所有的Exception进行try-catch.统一处理成自己的异常.

这样做的好处是.我们可以在架构层面把底层异常封装起来.进行一些特殊处理.让其他同学focus on business.
同时.对外返回统一的业务异常.可以方便使用者统一的进行处理.

2. 统一异常处理设计
一般在程序中.我们是不会到处使用try-catch的.会在 入口层面统一异常处理.返回特定的结果.如果是web服务器的架构.
可以使用filter或者springmvc 的interceptor这种方式.
这样做的好处就是可以定义一套完整的公用的异常处理内容.让业务异常统一处理
并且业务check代码也非常优雅.比如可以用Checker.notNull的方式进行检查.统一报错.这样就不用书写
if(obj ==null){//do something}这样的代码了

3. none Exception设计
关于这点可能有很多疑问.这里主要分业务系统和中间件.其实中间件还是会有很多的异常抛出的.
但是业务系统上一般都设计成没有任何异常抛出.因为对于系统异常.业务系统也需要返回一个特殊的处理内容.让外围可以明确的知道
否则每个系统抛出大量异常.会让调用方非常难以接受.

此外对于一些Aop的设计和处理.为了通用性考虑.我们一般也不会进行异常的抛出.

###封装,继承,多态,接口.
1.1.7 封装,继承,多态,接口.
这个概念实际上在面向对象中应该讲到.但是在面向对象里面我更加希望介绍面向对象是一种设计思想的方式
而这里的技术概念.是java来实现面向对象的一些基本方法.
首先必须了解面向对象的概念.这里建议大家重新阅读我之前的概述.并且在这之前建议大家了解面向对象五大原则
他们是:SRP单一职责,OCP开闭,LSP里式替换,DIP依赖倒置,ISP接口隔离

这些职责有很多相似的地方.大家一定完全的明白.并且了解每个原则的概念和细微的差别.比如SRP和OCP对于职责的处理是否有重复描述的地方?这些问题需要能够根据自己的理解来回答.

了解了这些概念之后.学习java如何实现面向对象就非常简单了.
1. 了解继承的基础内容.extends关键字.什么时候使用继承.为什么要用继承.继承解决了什么样的问题.然后是继承面试中问的,重写父类方法.
2. 需要明白什么是多态和java接口的概念.为什么要有interface而不是直接使用abstract class
3. 多态.什么是多态的概念.如何实现多态.如何设计多态.
4. 一些其他的面试题.如重写重载等.
这些基础内容说实话.多写写就知道了.但是知道和正确使用然后是正确设计有着非常大的鸿沟.

这里列举一个很简单的例子来让大家学习这些内容.
这个知识点可以配合设计模式来学习.我们以工厂模式来学习
设定一个工厂接口.他返回一个具体的对象实例.外围系统通过工厂来构建这个实例对象.
比如 ToyFactory.我们首先定义接口定义方法createToy.然后写一个实现类实现这个接口.如 R18ToyFactory.
返回R18的createToy,同样可以定义R14ToyFactory.返回另外的Toy.不同的Toy都是继承自父类AbstractToy

可以在Toy里面定义play方式.不同的工厂返回不同的toy具有不同的play.大家可以试试

简单总结
java实现面向对象需要了解面向对象原则.然后理解基础api的概念.然后配合设计模式来学习

###反射与注解
1.1.8 反射与注解
首先讲一下反射的概念.我们之前有讲过面向对象中的对象是一种抽象.抽象到后面只有特征.java在实现面向对象的时候使用class这个东西.
很自然的.我们能否针对class来进一步抽象呢.class中有方法.局部变量.构造方法等内容.其实反射就是把class进一步抽象.抽离出定义的class的更加基本的"特征".这些特征我们再次使用对象来表达.就是反射.即把java中的对象的特征来进一步抽象封装成更加基本的对象.
以上属于个人理解.
标准反射定义是java操作class的api.什么是反射大家还是基于资料自己来进行理解
然后学习反射中的基本操作.写一个类然后对应获得对应的class然后尝试做一些操作
java反射中有非常多的内容.大家一定要全部学习会.然后进行练习.因为从初级到中级开发.就是反射使用场景的变化
这里我简单介绍一下反射的场景.

1. 通用型框架
因为我们在写框架的时候是给后面的人用的.后面可以自由定义自己的class.所以框架全是基于反射来完成自己的功能的.
比如通用日志打印.新写一个类在方法上加一个@Log的注解就可以完成.其实就是通过反射来拦截具体的方法执行.
所以反射也和注解一起来使用.标记框架运行的方式.

这块的内容非常多.后面我会用具体的例子来说明.这里就不过多介绍了
2. 通用功能
我们提供一个通用的功能.可能只能基于Object或者泛型的方式来提供.因为这样可以提供更加丰富的功能.
但是这样我们就不知道基础类型了.所以只能通过反射的方式来完成.比如把一个bean转换成map
我们可以定义Object.然后通过反射的方式获取所有的变量.然后获取对应的值.转换成map返回.
典型的如BeanUtils的copy属性.就是基于反射来完成的.

简单总结一下吧
对于新手,可能需要完全了解到所有的java反射的操作.对于中级.更多的是需要把反射当成一种技术手段来完成自己的工作
如果是要面试,那么建议刷刷题即可

###告诫
主要的javase部分后面就不过多介绍了
相比一些市面上的内容我这里介绍的很粗
我只是针对各个常用知识点罗列了一些大家容易忽略的地方 并且记录了一些知识点大家需要重点理解的地方

大家千万不要觉得只要学习我说的就可以了 对于基础必须全面夯实

接下来简单介绍一下常用框架和一些简单的设计 或者更新一下lz的找工作经历了 最近真的忙 不一定什么时候更新

### 架构方法
- 一个架构的初步设计想法
当我们在说架构的时候是在说什么?为什么说运用面向对象是一种"设计"的方法.因为对于中级开发来说.往往面临一个独立的开发业务功能.那么如何实现这个功能,一定需要对功能进行"设计".他们会设计多少个类.设计整体的结构.

进一步,假如需要这个同学写一个企业级别的架构.那么需要怎么做呢?此时可能需要机遇现有业务情况做"设计"的"设计",进一步把我们组织代码的方式来进行抽象.这句话貌似很难理解.我来简单举个例子

1. 如果我们写数据层代码,使用jdbc来书写,那么可能10个业务都需要进行prepare,写sql,然后execute
2. ok,我们把这些数据库的操作全部面向对象.我们使用mybatis框架,不用面向jdbc了.仅仅需要书写很多个bean和对应的sql即可.
3. 如果我们有100个业务呢?我们发现所有的业务几乎都有getById方法,并且getById里面的sql都是全量返回一个bean的所有信息.那么我们是不是可以通过反射来实现这部分的功能,一个sql完成所有工作呢?

上面就是一层一层更加抽象的方式来组合我们的代码.

- 进阶思考
中级程序员面对的问题可能多种多样,此时他们会接触到另外一些方法论.比如aop.比如soa.比如mvc.比如微服务等等.

当我在罗列这些词语的时候感觉就看到了几年前的自己,感觉每个概念和每个技术都要运用到自己的设计或者架构中.

中级程序员慢慢自己手中的工具会越来越多.可选择的也越来越多.活灵活现的使用我上面的这些设计方法.并且有了自己的理解就可以慢慢成为高级程序员了


初级 thinking in java 研修设计模式 中级很广了我读的是 大型企业级架构 架构之美 人月神话 spring核心技术 redis设计与实现 storm核心技术 软件架构方法 等等 高级分很多种 一般可以看javaone上面的论文 活在infoq qcor上

###1.1.5 多线程与并发
多线程和容器需要一起来看.前几天面试一个同学的时候就挂在多线程这部分了.他说他的web开发中几乎用不到多线程.
当时我就立即说到.tomcat的线程模型是什么.不同的req是不是运行在不同的线程里面?只是你没有关注过罢了.

所以可以看出来.如果不是做基础架构.一般多线程使用场景较少.一般用多线程的场景也建议使用统一异步调度的方式来进行.
比如在蚂蚁,定时调度使用schedule和三层分发来做.
但是大家必须意识到.自己的程序天然就是运行在多线程里面的.

在面试过程中会单独考察多线程的概念和联合容器一起考察.后者工作中用到的更多.

java多线程体系:
1. 基本的多线程操作.Thread类.启动线程的方法.线程并发的概念.线程安全的处理方式.Sync的方式
然后就是 jdk 1.5中的concurrent包中的新的方式.Lock和Sync的区别.这些基础必须学习好
2. 线程通信的概念,notify的含义.volatile的底层处理方式
3. 底层cpu指令集.性能概述
4. 在工作中使用容器时的并发处理.如map是如何进行并发控制的ConcurrentHashMap和Collections.con的区别是什么.
5. 线程模型.如boss线程守护.多线程轮训的方式.这里涉及到线程池的概念.Executor的处理

多线程的内容非常非常多.需要大量的阅读书籍和练习才能掌握.对于一开始学习java来说.可以考虑先了解概念
针对面试常问的来学习.一般我在面试的时候会重点问下面几个问题
1. 多线程并发控制方式. 答案:api方式sync和lock. 设计方式去掉共享变量.
2. 容器的并发控制方式区别.map的区别和性能.
3. 线程池的相关操作.

由于一般在工作中极少极少用到notify相关内容.所以一般较少考察.不过建议大家学习的时候一定要学习会.
比如下面这个联系题
A,B,C三个线程执行任务.X发放任务.按照A->B->C的方式进行多线程处理任务.用代码实现.

希望大家思考思考.用sync和notify的方式来做

1.1.2 项目问题
具体肯定会问项目里面的很多细节
lz第一次面试的时候只有企业管理软件所以逗死三层架构部分 第二次面试是互联网公司 当时自己做了消息服务（消息队列） 统一session管理和sso 标准app的后台系统简单架构 这里分别说 注意这里的项目经验是lz自己的 所以每个人要对自己的项目足够了解

项目-标准三层架构
标准服务器三层架构的职责划分 每一层的技术选型 每一层的职责内容 每一层的设计规范 比如标准的web层使用springmvc框架 考虑的是外部交互封装的是视图（服务器的json）这些内容

2. 思路篇
其实如果一路看下来的同学会发现lz对思路非常非常重视 可以说整个帖子都是用自己的思路来拆开技能给大家讲 自己成长的经历就是思路更迭的过程 这个可以后面说说（又挖坑）
2.1 思路篇-简历
2.1.1 简历整体写什么
简历可以说是求职最重要的了 我们需要写联系方式 项目经历 自我介绍 教育信息 个人亮点 一个完整的建立必定是包含上面每一点的 请一定完整书写
2.1.2 项目经历
项目经历请一定一定参考我的建议 记住项目经历不是流水账记录你的工作内容 而是一个展示技能展示能力的工具 请一定记住没人会在意你之前项目是怎么做的 大家在意的是你用这个项目体现出来的能力
具体内容为
1. 项目概述 按照业务背景 项目目标 应用架构的方式来逐一描述自己的项目 概述就是用一句话来描述项目是在干什么 业务背景则需要描述业务场景 业务功能如果感觉自己nb可以介绍业务架构 应用架构可以简单理解为这个项目的技术选型和技术相关的架构 记住项目介绍的时候必须每个都涉及到
2. 自我职责
重点说明自己在项目中完成了什么内容 与第一点的不同地方是 第一点是整个项目的 哪怕不是自己做的也要介绍（因为这样可以体现自己的宏观思路和能力） 而这部分介绍自己在项目中承担的职责 即自己完成了哪部分工作 这部分工作的核心设计是什么 有哪些地方自己觉得很nb 并且针对哪些地方进行了深入了解
3. 项目递进
上面两点是必须写在简历里面的 而这点是需要融入道面试和简历中的 项目递进 主要是表现出自己的思考能力学习能力以及在项目中没有用到但是自己具备的能力 这也是面试中考察的重点 如
是否能具体介绍项目整体架构
目前架构是否合理 是否有更好的实现方式
如果业务量级翻十倍 那么目前的技术架构能否完成？

1. 自我介绍,重点介绍技术栈和项目经理
2. 结合项目直接问soa服务化拆分的原则和拆分的设计.引导水平拆分和垂直拆分的一些思考.由于候选人说没有做垂直拆分就无法进行追问.
3. 候选人提出自己写了一个分布式事务的sdk.所以针对分布式事务模型进行了提问,主要考察基于jta/xa两阶段模型上的设计和思考.没有发现对分布式事务模型进行过多了解和思考.后续追问如何实现一阶段/二阶段.但是候选人对于xa模型不太理解.后续提醒之后发现对于transactionManager还是有所设计.但是没有详细了解关于分布式事务一致性的保障问题.如事务恢复涉及.
4. 提到弱一致性的读高并发.进而进行问如何解决高并发写的问题.候选人提出使用redis进行缓冲记录库存的方案.以及提出使用处理请求队列的方案.进而提问对于请求队列导致的时效性降低(异步化)如何解决.候选人没有理解
5. javacore问题.多线程线程池参数问题,coresize,maxsize等参数是否了解,回答不完美.

面试别人 2019-02-21 15:51
1. 自我介绍
主要精力是后台维护工作.用springMvc及mybatis等内容.

2. 框架技术内容
问对于restfull的理解.问对于restfull和springmvc的设计如何实现的多视图.以及操作幂等性.整体回答不是很好.对于幂等性没有理解深刻,回答同请求加密来进行绑定判断.同时对于restfull这种的
候选人使用了redis.就redis进行问redis的使用场景.回答订单缓存和订单的加锁,进一步追问如何来实现的订单加锁,进一步追问是否有数据单点问题,是否有对于单点问题的解决方案.候选人没有给出答案

3. 对于aop编程思想的提问
问什么是aop,以及如何使用的aop.候选回答的全是springmvc相关的内容.以及如何实现springmvc,对于aop的使用概念和理念没有理解清晰.并且回答很久不用了所以不记得了.现在的系统也没有使用
扩展性问题,如何让候选人重新设计自己的系统架构如何来进行设计.
候选人回答到了对于数据进行拆分.所以追问如何拆表和拆表后对于数据一致性如何保证.发现候选人对数据一致性不了解.

4. javacore相关问题
问候选人hashmap的内存结构.回答链表散列.达到3/4会进行扩展.为什么是3/4(默认的负载系数)候选人没回答上来.对于rehash也没有回答ok,对于如何确定数组的index没有回答上来.对于jkd1.8没有涉及.
对于如何控制并发.候选人答实际工作中没有使用.没有了解到.


lz的自我学习经历

先明确一点.我的经历已经是快五年前的了.所以希望大家结合现在的变化来进行更新.
并且当初由于处于O2O风口,所以经济形势很好.上海很多创业公司,lz也是加入了一家初创公司.打下了架构基础.
目前已经快三年没有找工作了.所以不太确定目前就业形势.不过从猎头给我的反馈来看还不错.

1. lz学习java的经历.

学习java的经历可以说是废寝忘食.有近半年的时间吧(太久远忘记了).lz的作息是
早上7点起床洗漱吃早点.开始看视频.一直看到中午.下午继续看视频或者回顾视频中的内容.完全自学加写代码.
晚上加深学习加扩展内容.根据进度学习到凌晨1点到3点.期间没有上过网.没有任何娱乐活动.


1.1 javase部分
这部分内容.lz是根据张孝祥老师的java基础视频和尚学堂马士兵老师的教学视频来学习的(百度 张孝祥 java视频).两位都是大师

不了解现在的学习视频是怎么样的.所以lz整理一下更体系一些的学习内容
这里简单介绍一下每个知识点学习的一些重点和方法.
纯手打.有错误大家回复指正

1.1.1 java概念和环境
跟着视频了解java的概念.jdk的安装.jvm的概念.环境变量的意思.然后下载好所有的软件.配置好java_home.
使用cmd运行一下java -version命令.了解这些后应该就感觉很神奇了.可以尝试理解一下java是一门面向对象语言的概念

接下来可以自己尝试java的所有命令.不过我还是建议接下来这么做.

自己建立一个文件夹.比如study.然后javaday1目录.新建一个txt文件.然后写下自己第一个程序.hello world(这些不用我来说了吧汗)
一定要用txt.更改为java文件,然后按照指导运行javac命令编译好自己的class文件.然后运行这个java文件.
恭喜大家.见到了自己书写的第一个程序.

一定一定使用txt来完成这个内容.这是对java一个最感性,也是最geek的做法.很多时候可能一个很小的操作就表现出了差距.

做完这一切之后可能很快也可能花费了一天的时间(对于很多初学者建议也自己用txt写一个hello world)

不过我相信对于很多人来说今天注定是一个不眠夜.从今天开始.我们选择了java这个程序.走上了开发这条路
未来是迷茫的,唯有指下的键盘能指引我们方向.

对于进度快的同学.可以思考一个问题.什么是"对象".(当然可以直接背下我之前说的面向对象的解释然后用在面试中,相信我绝对加分)
如果开始思考"对象"这个词那么可能这一天都无法睡觉了.这里介绍一个重要的概念"抽象"
抬起头看.映入眼帘的是电脑屏幕.如果我们抽象起来,就变成了一个图形显示器.进一步抽象他就是一个颜色输出器.进一步它就是一个outputer.ok这个所谓的outputer就是对象了

思考完对象.大家可以进而思考和学习我们写的程序里面这个class是什么意思.这个东西叫"类"那java中类是什么意思.
可以认为类是java语言对于对象的代码静态表达.大家可以自行学习

那么总结今天我们学习了
1. java概念与环境,写了hello world
2. 知道有"对象"这个东西
3. 知道有"类"这个东西,一切的java代码都要用类来写

1.1.2 java基本类型与关键字.操作符

我发现写太多实在进度太慢了.不过我还是讲解的细化一些吧.后面整理一下再发出来.

好了.开始新的一天.我们昨天写了hello world.今天我们要开始学习java的语法和基本操作了
这里也可以对着书,或者对着视频,甚至对着我的这个文章.
记得把所有的代码全部认认真真的用手写一遍.手写.对.要么用txt.要么用笔

首先是java的基本类型.比如int这个.这个标识一个正短整数.我们需要学习有哪些基本类型.并且记忆每个基本类型内存大小是多少
如果超过了内存大小会发生什么.好了我这里记录了三个问题.大家可以找答案,然后对每个类型都进行一下操作
这里比如int.大家可以写这个代码
int a = 2147483647;int b = a+1;System.out.println(a);System.out.println(a+1);System.out.println(b);
然后大家看一下发生了什么.然后仔细想想为什么运行结果是这样的.这里就涉及java对于数据的内存计算和存储了.一定要学会

知道了这些后需要学习操作符.比如 + - * /这些.这些都是操作符.他们是干什么用的.这里肯定大家会笑了
比如很简单 1+1 大家都知道.但是2*2 是怎么做的?有没有人人为我在开玩笑?
大家确定明白了么?那么请运行下面这个代码
System.out.println(2<<1);System.out.println(2*2);
好了.大家应该明白了.需要学习这些操作符对应到二进制之后java是怎么做的.并且每个操作符是怎么实现的.
好了.此外还有最经典的操作符了. a--和--a.那么大家可以写很多这样的代码.
比如
int a = --1;
int b = 1--;
然后看各个情况有什么差别.

我没有列出来每个关键点.我只是用一个例子来说明这一天将尽 16个小时大家要怎么学习,学习什么内容.
今天大家应该学习了
1. 基本关键字与基本类型
2. 操作符
3. 逻辑表达式(!,&&,&这些)
4. if-else

1.1.3 java初始化,内存分配与gc
java相对于c++来说,对于内存的使用"智能"了很多.不用手工清理内存,也不用手工初始化内存.
但是编程语言仅仅是一种工具.我们要正确的理解如何干活,之后工具仅仅是协助我们干好活的一个手段.
所以对于一些偏底层及原理性内容需要完全理解

首先是初始化内容,对于constructor理解概念,知道是静态代码和"实例对象"的概念.这个概念会伴随我们使用java的全部生涯.
不要小看这个概念,这里简单介绍一下.我们的所有架构设计都是面对静态代码的.代码运行的针对我们的设计会具象化到某个场景
这就是实例对象.
在大型系统架构中,涉及复杂业务及系统架构.我们往往使用"配置化"的表达方式来进行涉及,这其实就一个静态代码和实例对象的关系.

然后需要了解一个完整的实例对象的顺序问题.比如成员变量,静态变量.构造方法,构造代码块,这些顺序.写一个程序会帮助大家理解的更深.

然后就是重中之重.java的内存分配了.对于一个初学者.可能无法理解太深的java内存分配的原理.所以这部分就是靠记忆来理解.
比如最简单的堆,栈,方法区.这三个内存.
同时,需要联系我们上面说的初始化内容来学习这里.比如一行代码:
String a = new String("a");
这里会开辟几个内存空间?依次的顺序是什么?引用关系是什么?这些需要大家都弄清楚.

然后,非常建议大家提前了解一些gc原理.java是被动式的gc.通过System.gc();也是无法强制gc的.关于gc的文章非常非常多.
大家可以简单了解一下gc对于堆内存的划分.知道概念即可.因为涉及到了内存.所以gc一定要配合学习一下.

总结一下
1. 我们学习了java初始化.重点理解实例对象概念,需要记忆初始化顺序问题,基本技能是构造方法
2. 学习了内存分配.知道当我们进行变量声明,赋值,实例化对象的时候内存发送了什么样子的变化.分别每部分内存是哪.
3. 对于gc知道了这么一个东西.

1.1.4 数组,容器
java提供了一套非常有用且强大的api,通过这套api几乎可以满足绝大部分工作中对于数据存储转换传递的需要.
这就是java的容器类.这里的容器是指java当中存放对象的一些数据结构.简单来说就是放数据的内容
学习容器首先需要理解容器的概念和容器能帮助我们做什么.在实际工作中经常会对一些数据处理.通过java处理一批数据必定需要
把这些数据放起来.然后做操作.java当中的容器就是放这些东西的类.

就像之前我所讲的.对于面向对象来说,我们需要对于我们的功能进行抽象.所以java当中提供了一些接口来表达容器对应的功能
容器有:Collection,Map
进一步划分有:List,Set
容器的实现有:
ArrayList,LinkedList,Vector->Stack
HashSet->LinkedHashSet,TreeSet
HashMap->LinkedHashMap,TreeMap
这里就很有意思了.大家发现实现类有这么多种,是不是没一个都是不用的用法呢?
其实只有两个,一个是Collection一个是Map.
这就是我之前说的抽象的概念,我们抽象的是通用操作方法.不同的实现提供的是内部不同的功能实现.一个相同的操作方法可能会有不同的表现形式.希望大家体会体会.

同样,对于容器的迭代使用java也抽象出了公用的迭代器:Iterator,用于封装同样的访问方法.虽然map无法直接使用迭代器进行访问,但是map的key和entry是可以使用的.这些内容比较基础.大家学习会各个容器的访问和设置方法自己多联系联系即可

下面说一些学习核心:
1. 对于了解容器类.首先需要了解的是每一个不同容器的实现逻辑和内存结构.一定要至少知道内存结构.比如ArrayList是一个数组,LinkedList是一个链表结构.
同样的.对于HashMap重点理解"链表散列"这个概念.如果实在无法理解,就多多看几遍代码.HashMap在设计上有个hash思想.这个通过Hash值来离散数据的设计可以用在很多地方.可以多多理解,比如数据水平拆分,负载均衡设计.包括分布式缓存中的一致性hash设计.都是基于这个.

2. 对于不同内存结构.带来功能和性能上的不同需要理解到.比如经常问到的Array和Linked这两个的性能区别和使用场景区别
需要能够自己理解到.比如随机访问的情况用LinkedList还是ArrayList?
答案是都不用,重写hashCode方法然后用HashMap.希望大家真的能理解这点.

3. 对于容器的迭代器.插入删除的并发控制.目前记住这点内容即可.后续在并发的时候重点有并发的讲解

4. map是一个很特殊的容器.因为使用场景实在太多了.所以jdk1.8对hashMap进行了优化.大家一定要去详细了解一下.(这里不说了.因为这个都已经可以形成一个blog了)

5. 常用编程规范.目前学习到现在应该养成一些编程规范了.比如初始化容器的时候指定大小这些.


1.1.6 java异常处理
java对于异常很多人诟病很多.不过基于java异常也可以实现很多优雅的设计.
并且异常也是非常多架构设计中需要考虑的内容.所以针对java的异常学习.除了需要学习基本的概念意外.
需要重点掌握的是针对异常的一些设计.
对于基础知识.
1. 最简单的.了解Throwable,Error,Exception,RuntimeException这些的概念.并且知道用法.对于try-catch-finally需要明白是做什么的
2. 异常设计.一些基本的设计概念.比如通用的需要检查的异常处理内容.方法上抛出的异常.try-catch处理转换.日志打印等内容

对于基础知识来说大家肯定用到了.比如多线程的时候就有打断异常.所以这里不过多介绍.
我更加想给大家介绍一些基本的异常设计方法.可能大家不会太理解.不过知道这个概念也行

工业场景下的典型异常设计方法:
1. RuntimeException
事实上,对于Exception真的是深恶痛绝.这个东西真的会让代码变的非常难看.我们更希望使用非检查异常.并且是自定义异常.
所以最基础的就是.一般我们会设计一个基础异常比如 MyException 继承RuntimeException.
然后把所有的Exception进行try-catch.统一处理成自己的异常.

这样做的好处是.我们可以在架构层面把底层异常封装起来.进行一些特殊处理.让其他同学focus on business.
同时.对外返回统一的业务异常.可以方便使用者统一的进行处理.

2. 统一异常处理设计
一般在程序中.我们是不会到处使用try-catch的.会在 入口层面统一异常处理.返回特定的结果.如果是web服务器的架构.
可以使用filter或者springmvc 的interceptor这种方式.
这样做的好处就是可以定义一套完整的公用的异常处理内容.让业务异常统一处理
并且业务check代码也非常优雅.比如可以用Checker.notNull的方式进行检查.统一报错.这样就不用书写
if(obj ==null){//do something}这样的代码了

3. none Exception设计
关于这点可能有很多疑问.这里主要分业务系统和中间件.其实中间件还是会有很多的异常抛出的.
但是业务系统上一般都设计成没有任何异常抛出.因为对于系统异常.业务系统也需要返回一个特殊的处理内容.让外围可以明确的知道
否则每个系统抛出大量异常.会让调用方非常难以接受.

此外对于一些Aop的设计和处理.为了通用性考虑.我们一般也不会进行异常的抛出.

1.1.7 封装,继承,多态,接口.
这个概念实际上在面向对象中应该讲到.但是在面向对象里面我更加希望介绍面向对象是一种设计思想的方式
而这里的技术概念.是java来实现面向对象的一些基本方法.
首先必须了解面向对象的概念.这里建议大家重新阅读我之前的概述.并且在这之前建议大家了解面向对象五大原则
他们是:SRP单一职责,OCP开闭,LSP里式替换,DIP依赖倒置,ISP接口隔离

这些职责有很多相似的地方.大家一定完全的明白.并且了解每个原则的概念和细微的差别.比如SRP和OCP对于职责的处理是否有重复描述的地方?这些问题需要能够根据自己的理解来回答.

了解了这些概念之后.学习java如何实现面向对象就非常简单了.
1. 了解继承的基础内容.extends关键字.什么时候使用继承.为什么要用继承.继承解决了什么样的问题.然后是继承面试中问的,重写父类方法.
2. 需要明白什么是多态和java接口的概念.为什么要有interface而不是直接使用abstract class
3. 多态.什么是多态的概念.如何实现多态.如何设计多态.
4. 一些其他的面试题.如重写重载等.
这些基础内容说实话.多写写就知道了.但是知道和正确使用然后是正确设计有着非常大的鸿沟.

这里列举一个很简单的例子来让大家学习这些内容.
这个知识点可以配合设计模式来学习.我们以工厂模式来学习
设定一个工厂接口.他返回一个具体的对象实例.外围系统通过工厂来构建这个实例对象.
比如 ToyFactory.我们首先定义接口定义方法createToy.然后写一个实现类实现这个接口.如 R18ToyFactory.
返回R18的createToy,同样可以定义R14ToyFactory.返回另外的Toy.不同的Toy都是继承自父类AbstractToy

可以在Toy里面定义play方式.不同的工厂返回不同的toy具有不同的play.大家可以试试

简单总结
java实现面向对象需要了解面向对象原则.然后理解基础api的概念.然后配合设计模式来学习

1.1.8 反射与注解
首先讲一下反射的概念.我们之前有讲过面向对象中的对象是一种抽象.抽象到后面只有特征.java在实现面向对象的时候使用class这个东西.
很自然的.我们能否针对class来进一步抽象呢.class中有方法.局部变量.构造方法等内容.其实反射就是把class进一步抽象.抽离出定义的class的更加基本的"特征".这些特征我们再次使用对象来表达.就是反射.即把java中的对象的特征来进一步抽象封装成更加基本的对象.
以上属于个人理解.
标准反射定义是java操作class的api.什么是反射大家还是基于资料自己来进行理解
然后学习反射中的基本操作.写一个类然后对应获得对应的class然后尝试做一些操作
java反射中有非常多的内容.大家一定要全部学习会.然后进行练习.因为从初级到中级开发.就是反射使用场景的变化
这里我简单介绍一下反射的场景.

1. 通用型框架
因为我们在写框架的时候是给后面的人用的.后面可以自由定义自己的class.所以框架全是基于反射来完成自己的功能的.
比如通用日志打印.新写一个类在方法上加一个@Log的注解就可以完成.其实就是通过反射来拦截具体的方法执行.
所以反射也和注解一起来使用.标记框架运行的方式.

这块的内容非常多.后面我会用具体的例子来说明.这里就不过多介绍了
2. 通用功能
我们提供一个通用的功能.可能只能基于Object或者泛型的方式来提供.因为这样可以提供更加丰富的功能.
但是这样我们就不知道基础类型了.所以只能通过反射的方式来完成.比如把一个bean转换成map
我们可以定义Object.然后通过反射的方式获取所有的变量.然后获取对应的值.转换成map返回.
典型的如BeanUtils的copy属性.就是基于反射来完成的.

简单总结一下吧
对于新手,可能需要完全了解到所有的java反射的操作.对于中级.更多的是需要把反射当成一种技术手段来完成自己的工作
如果是要面试,那么建议刷刷题即可