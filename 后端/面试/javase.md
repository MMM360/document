临时
& 
二叉查找树--》红黑树
^(h = key.hashCode()) ^ (h >>> 16) 
抽象类的使用
为什么stringbuilder有顶层抽象类
双向列表
将链表转化为红黑树
状态码

##
1. private修饰的方法可以通过反射访问，那么private的意义是什么
	1.java的private修饰符并不是为了绝对安全性设计的，更多是对用户常规使用java的一种约束；
	2.从外部对对象进行常规调用时，能够看到清晰的类结构。
   
2. Java类初始化顺序
	测试单类的初始化顺序: 
					   静态变量 > 静态初始块 > 成员变量 > 非静态初始块 > 构造器
	含有继承相关类的初始化顺序为: 
							  父类静态变量 > 父类静态初始块 > 子类静态变量 > 子类静态初始块 > 父类成员变量 > 父类非静态初始块 > 父类构造器 > 子类成员变量 > 子类非静态初始块 > 子类构造器
			
3. 对方法区和永久区的理解以及它们之间的关系
	 方法区是jvm规范里要求的，永久区是Hotspot虚拟机对方法区的具体实现，前者是规范，后者是实现方式。jdk1.8作了改变。本题看看对方在思想层面对jvm的理解程度，很基础的一个题目	

4. 一个java文件有3个类，编译后有几个class文件
	  文件中有几个类编译后就有几个class文件。

5. 局部变量使用前需要显式地赋值，否则编译通过不了，为什么这么设计
	 成员变量是可以不经初始化的，在类加载过程的准备阶段即可给它赋予默认值，但局部变量使用前需要显式赋予初始值，javac不是推断不出不可以这样做，而是没有这样做，对于成员变量而言，其赋值和取值访问的先后顺序具有不确定性，对于成员变量可以在一个方法调用前赋值，也可以在方法调用后进行，这是运行时发生的，编译器确定不了，交给jvm去做比较合适。而对于局部变量而言，其赋值和取值访问顺序是确定的。这样设计是一种约束，尽最大程度减少使用者犯错的可能（假使局部变量可以使用默认值，可能总会无意间忘记赋值，进而导致不可预期的情况出现）。

6. ReadWriteLock读写之间互斥吗
	 ReadWriteRock 读写锁，使用场景可分为读/读、读/写、写/写，除了读和读之间是共享的，其它都是互斥的，接着会讨论下怎样实现互斥锁和同步锁的， 想了解对方对AQS，CAS的掌握程度，技术学习的深度。
7. Semaphore拿到执行权的线程之间是否互斥

8. 写一个你认为最好的单例模式
	public class Singleton {
    private Singleton() {}
    private volatile static Singleton instance;
    public static Singleton getInstance() {
        if (null == instance) {
            synchronized (Singleton.class) {
                if (null == instance) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    	}
	}
	
9. B树和B+树是解决什么样的问题的，怎样演化过来，之间区别
	
10. 写一个生产者消费者模式

写一个死锁

12. cpu 100%怎样定位
	top -d 1 -c

13. String a = "ab"; String b = "a" + "b"; a == b 是否相等，为什么
	String a = "ab"; String b = "a" + "b"; a ，b 是相等的（各位要写代码验证一下，我看到有人写了错误答案）。常规的问法是new一个对象赋给变量，问：这行表达式创建了几个对象，但这样的题目太常见。

14. int a = 1; 是原子性操作吗
	int a = 1; 是原子性操作

15. 可以用for循环直接删除ArrayList的特定元素吗？可能会出现什么问题？怎样解决
	for循环直接删除ArrayList中的特定元素是错的，不同的for循环会发生不同的错误，泛型for会抛出 ConcurrentModificationException，普通的for想要删除集合中重复且连续的元素，只能删除第一个。
	
	错误原因：打开JDK的ArrayList源码，看下ArrayList中的remove方法（注意ArrayList中的remove有两个同名方法，只是入参不同，这里看的是入参为Object的remove方法）是怎么实现的，一般情况下程序的执行路径会走到else路径下最终调用faseRemove方法,会执行System.arraycopy方法，导致删除元素时涉及到数组元素的移动。针对普通for循环的错误写法，在遍历第一个字符串b时因为符合删除条件，所以将该元素从数组中删除，并且将后一个元素移动（也就是第二个字符串b）至当前位置，导致下一次循环遍历时后一个字符串b并没有遍历到，所以无法删除。针对这种情况可以倒序删除的方式来避免
	新的任务提交到线程池，线程池是怎样处理
	
	解决方案：用 Iterator。
	 List<String> list = new  ArrayList(Arrays.asList("a", "b",  "b" , "c", "d"));
	 Iterator<String> iterator = list.iterator();
	       while(iterator.hasNext()) {
	           String element = iterator.next();
	           if(element.equals("b")) {
	               iterator.remove();
	           }
	将本问题扩展一下，下面的代码可能会出现什么问题？

	ArrayList<String> array = new ArrayList<String>();
	array.add(1,"hello world");

16. 新的任务提交到线程池，线程池是怎样处理
	第一步 ：线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则执行第二步。

	第二步 ：线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里进行等待。如果工作队列满了，则执行第三步。
	
	第三步 ：线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。

AQS和CAS原理
synchronized底层实现原理

19. volatile作用，指令重排相关
	多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据
	代码底层执行不像我们看到的高级语言—-Java程序这么简单，它的执行是Java代码–>字节码–>根据字节码执行对应的C/C++代码–>C/C++代码被编译成汇编语言–>和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率

AOP和IOC原理
Spring怎样解决循环依赖的问题
dispatchServlet怎样分发任务的
mysql给离散度低的字段建立索引会出现什么问题，具体说下原因

